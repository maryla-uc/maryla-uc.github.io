<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha Compositing Tool</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .info {
            margin-top: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
            line-height: 1.4;
        }
        .warning {
            color: #d9534f;
            font-weight: bold;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex: 1 1 auto;
            min-width: 220px;
        }

        .label-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            /* This replaces the margin on the label */
            margin-bottom: 5px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #a0a0a0;
            color: white;
            font-size: 13px;
            font-style: italic;
            font-family: Georgia, serif;
            font-weight: bold;
            cursor: help;
            user-select: none;
            line-height: 18px; /* Center 'i' vertically */
        }

        .tooltip .tooltip-content {
            visibility: hidden;
            opacity: 0;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 10;
            bottom: 140%; /* Position above the icon */
            left: 50%;
            transform: translateX(-50%);
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            /* Reset styles inherited from label */
            font-weight: normal;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Show on hover */
        .tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        #transferFunctionGroup {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        label {
            font-weight: bold;
            color: #555;
            text-align: left;
        }

        select, input[type="range"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            width: 100%;
            box-sizing: border-box;
            -webkit-appearance: none;
            appearance: none;
            background: #f0f0f0;
            outline: none;
            cursor: pointer;
        }

        /* Tooltip arrow */
        .tooltip .tooltip-content::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }


        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 1px solid #007bff;
        }
        input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 1px solid #007bff;
        }

        canvas {
            border: 2px solid #333;
            background-color: #eee;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            .control-group {
                width: 100%;
                max-width: 300px;
            }
            h1 {
                font-size: 1.5em;
            }
        }

        .previews-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
            width: 100%;
            flex-wrap: wrap;
        }

        .preview-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .preview-item label {
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #666;
            font-weight: normal;
        }

        .preview-item img {
            width: 150px;
            min-height: 75px; /* Prevent collapse while loading, height is set by JS */
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            object-fit: fill;
        }

        .color-preview {
            width: 150px;
            min-height: 75px; /* Prevent collapse while loading, height is set by JS */
            border: 1px solid #ccc;
            background-color: #f9f9f9; /* Fallback for when color is not set */
        }

        .preview-separator {
            font-size: 2.5em;
            color: #888;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Alpha Compositing Comparison Tool</h1>
        <div class="info">
            Note that computation for HDR images is done in 8bit so banding may be visible. This is a limitation of this demo.
            <div id="experimentalFlagsRuntimeWarning" class="warning" style="display: none; margin-top: 10px; padding: 10px; border: 1px solid #d9534f; border-radius: 4px;">
                <strong>HDR images will not work unless viewed in Chrome with the Experiment Platform Features flag enabled: chrome://flags/#enable-experimental-web-platform-features<br/>
                    You also need an HDR display to see anything interesting!
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="label-wrapper">
                    <label for="backgroundColor">Background Color:</label>
                    <div class="tooltip">
                        <span class="tooltip-icon">i</span>
                        <span class="tooltip-content">Color of the background layer. The foreground image will be blended on top of this color.</span>
                    </div>
                </div>
                <select id="backgroundColor">
                    <option value="#000000">Black</option>
                    <option value="#FFFFFF">White</option>
                    <option value="#949494">Gray</option>
                    <option value="#FF0000" selected>Red</option>
                    <option value="#00FF00">Green</option>
                    <option value="#0000FF">Blue</option>
                    <option value="#FFFF00">Yellow</option>
                    <option value="#FF00FF">Magenta</option>
                    <option value="#00FFFF">Cyan</option>
                </select>
            </div>

            <div class="control-group">
                <div class="label-wrapper">
                    <label for="foregroundImage">Foreground Image:</label>
                    <div class="tooltip">
                        <span class="tooltip-icon">i</span>
                        <span class="tooltip-content">Image that will be blended on top of the background color, using the provided alpha mask. Images marked 'HDR (PQ)' are High Dynamic Range and require a compatible display and browser for correct viewing.</span>
                    </div>
                </div>
                <select id="foregroundImage">
                    <option value="data/pigeon.jpg">Pigeon SDR</option>
                    <option value="data/rainbow.png" selected>Rainbow SDR</option>
                    <option value="data/pigeon-pq.avif">Pigeon HDR (PQ)</option>
                    <option value="data/olympics-pq.avif">Olympics HDR (PQ)</option>
                    <option value="data/night-pq.avif">Night (PQ)</option>
                    <option value="data/rainbow2-pq.avif">Rainbow HDR (PQ)</option>
                </select>
            </div>

            <div class="control-group">
                <div class="label-wrapper">
                    <label for="alphaMask">Alpha Mask:</label>
                    <div class="tooltip">
                        <span class="tooltip-icon">i</span>
                        <span class="tooltip-content">A grayscale image used to define the opacity for the foreground image.</span>
                    </div>
                </div>
                <select id="alphaMask">
                    <option value="data/opaque.png">Opaque</option>
                    <option value="data/gray.png">Half Opaque</option>
                    <option value="data/round.png" selected>Circle</option>
                    <option value="data/cube.jpg">Cube</option>
                    <option value="data/bwgradient.png">Gradient</option>
                </select>
            </div>

            <div class="control-group">
                <div class="label-wrapper">
                    <label for="premultiplication">Premultiplication:</label>
                    <div class="tooltip">
                        <span class="tooltip-icon">i</span>
                        <span class="tooltip-content">Defines whether the foreground image is multiplied by the alpha value *before* the main blending step, and in which color space if so.</span>
                    </div>
                </div>
                <select id="premultiplication">
                    <option value="None" selected>None</option>
                    <option value="Gamma">Gamma RGB</option>
                    <option value="Linear">Linear RGB</option>
                    <option value="YUV">YUV</option>
                </select>
            </div>

            <div class="control-group">
                <div class="label-wrapper"> 
                    <label for="blendingColorSpace">Compositing Space:</label> 
                    <div class="tooltip"> 
                        <span class="tooltip-icon">i</span> 
                        <span class="tooltip-content">The color space where the compositing formula is applied. 'Linear RGB' is physically accurate and produces the best visual results. 'Gamma RGB' is a common but less accurate method. 'YUV' is less common, and produces wrong results when RGB premultiplication is used.</span> 
                    </div>
                </div>
                <select id="blendingColorSpace">
                    <option value="RGB_Gamma" selected>Gamma RGB</option>
                    <option value="RGB_Linear">Linear RGB</option>
                    <option value="YUV_Full">YUV (BT.709 Full Range)</option>
                    <option value="YUV_Limited">YUV (BT.709 Limited Range)</option>
                </select>
            </div>

            <div class="control-group" id="transferFunctionGroup">
                <div class="label-wrapper">
                    <label for="transferFunction">Transfer Function:</label>
                    <div class="tooltip">
                        <span class="tooltip-icon">i</span> 
                        <span class="tooltip-content">The function used to convert image color values to and from a linear light representation. Used when Compositing Space or Premultiplication is set to 'Linear RGB'. This should match the source image's encoding (i.e. sRGB for most web images, PQ for HDR).</span> 
                    </div>
                </div>
                <select id="transferFunction">
                    <option value="sRGB_IEC_61966_2_1">sRGB</option>
                    <option value="BT_709">BT.709</option>
                    <option value="PQ">PQ</option>
                    <option value="Gamma_2_2">Gamma 2.2</option>
                    <option value="Gamma_2_4">Gamma 2.4</option>
                    <option value="Gamma_2_8">Gamma 2.8</option>
                </select>
            </div>
        </div>

        <canvas id="blendCanvasSrgb"></canvas>
        <canvas id="blendCanvasPq"></canvas>

        <div class="previews-container">
            <div class="preview-item">
                <label>Background Color</label>
                <div id="backgroundPreview" class="color-preview"></div>
            </div>
            <div class="preview-separator">+</div>
            <div class="preview-item">
                <label>Foreground Image</label>
                <img id="foregroundPreview" alt="Foreground Image Preview">
            </div>
            <div class="preview-separator">+</div>
            <div class="preview-item">
                <label>Alpha Mask</label>
                <img id="alphaMaskPreview" alt="Alpha Mask Preview">
            </div>
        </div>

        <div class="info" style="margin-top: 30px; font-size: 0.8em;">
            <small>Cube alpha mask image from <a href="https://en.wikipedia.org/wiki/File:Cubic_Structure_and_Floor_Depth_Map_with_Front_and_Back_Delimitation.jpg" target="_blank" rel="noopener noreferrer">Wikipedia</a>, CC BY-SA 4.0.</small><br>
            <small>Everything else Copyright Maryla U.C. 2025 CC-BY 4.0</small>
        </div>
    </div>

    <script type="text/javascript">
    document.addEventListener('DOMContentLoaded', () => {
        const backgroundColorSelect = document.getElementById('backgroundColor');
        const foregroundImageSelect = document.getElementById('foregroundImage');
        const alphaMaskSelect = document.getElementById('alphaMask');
        const blendingColorSpaceSelect = document.getElementById('blendingColorSpace');
        const transferFunctionSelect = document.getElementById('transferFunction');
        const transferFunctionGroup = document.getElementById('transferFunctionGroup');
        const premultiplicationSelect = document.getElementById('premultiplication');
        const blendCanvasSrgb = document.getElementById('blendCanvasSrgb');
        const blendCanvasPq = document.getElementById('blendCanvasPq');
        const experimentalFlagsWarningDiv = document.getElementById('experimentalFlagsRuntimeWarning');
        const foregroundPreview = document.getElementById('foregroundPreview');
        const alphaMaskPreview = document.getElementById('alphaMaskPreview');
        const backgroundPreview = document.getElementById('backgroundPreview');

        const settingsToPersist = [
            'backgroundColor',
            'foregroundImage',
            'alphaMask',
            'blendingColorSpace',
            'transferFunction',
            'premultiplication'
        ];

        const settingsKeyMap = {
            'backgroundColor': 'bg',
            'foregroundImage': 'fg',
            'alphaMask': 'am',
            'blendingColorSpace': 'cs',
            'transferFunction': 'tf',
            'premultiplication': 'pm'
        };
        // Create a reverse map for loading
        const reverseSettingsKeyMap = Object.fromEntries(Object.entries(settingsKeyMap).map(([k, v]) => [v, k]));

        function saveSettingsToHash() {
            const settings = {};
            settingsToPersist.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    const shortKey = settingsKeyMap[id] || id;
                    settings[shortKey] = element.value;
                }
            });
            window.location.hash = new URLSearchParams(settings).toString();
        }

        function loadSettingsFromHash() {
            if (window.location.hash && window.location.hash.length > 1) {
                const params = new URLSearchParams(window.location.hash.substring(1));
                params.forEach((value, shortKey) => {
                    const originalId = reverseSettingsKeyMap[shortKey] || shortKey;
                    const element = document.getElementById(originalId);
                    if (element && settingsToPersist.includes(originalId)) {
                        element.value = value;
                    }
                });
            }
        }

        function updateForegroundImage(src) {
            foregroundImage.src = src;
            if (foregroundPreview) {
                foregroundPreview.src = src;
            }
        }

        function updateAlphaMask(src) {
            alphaMaskImage.src = src;
            if (alphaMaskPreview) {
                alphaMaskPreview.src = src;
            }
        }

        function updateBackgroundColorPreview(color) {
            if (backgroundPreview) {
                backgroundPreview.style.backgroundColor = color;
            }
        }

        function adjustTransferFunctionForImage(imageSrc) {
            const isPqImage = imageSrc.includes("-pq.");
            const currentTfValue = transferFunctionSelect.value;
            let targetTfValue;

            if (isPqImage) {
                targetTfValue = 'PQ';
            } else {
                targetTfValue = 'sRGB_IEC_61966_2_1';
            }

            if (currentTfValue !== targetTfValue) {
                // Check if the targetTfValue is a valid option to prevent errors
                const optionExists = Array.from(transferFunctionSelect.options).some(opt => opt.value === targetTfValue);
                if (optionExists) {
                    transferFunctionSelect.value = targetTfValue;
                    return true; // Indicates a change was made
                } else {
                    console.warn(`Attempted to set transfer function to non-existent option: ${targetTfValue} for image ${imageSrc}`);
                }
            }
            return false; // No change made or target option didn't exist
        }
        // Attempt to get a 2D context with experimental HDR options
        let ctxSrgb = null;
        let ctxPq = null;
        try {
            ctxSrgb = blendCanvasSrgb.getContext('2d', {
                alpha: true, // Keep alpha for transparency
                colorSpace: 'srgb',
                // pixelFormat: 'float16'    // Experimental 16-bit float pixel format
            });
            ctxPq = blendCanvasPq.getContext('2d', {
                alpha: true, // Keep alpha for transparency
                colorSpace: 'rec2100-pq', // Experimental HDR color space
                // pixelFormat: 'float16'    // Experimental 16-bit float pixel format
            });

            if (!ctxSrgb) {
                ctxSrgb = blendCanvas.getContext('2d'); // Fallback to default
                console.warn("Failed to create Canvas 2D context with HDR options. Falling back to default sRGB 8-bit.", ctxSrgb.getContextAttributes())
            }
            if (ctxPq) {
                let actualColorSpace = ctxSrgb.getContextAttributes().colorSpace;
                let actualPixelFormat = 'Unknown'; // pixelFormat is not exposed in attributes
                console.log("Canvas 2D context created with experimental HDR options:", ctxSrgb.getContextAttributes());
            } else {
                ctxSrgb = blendCanvas.getContext('2d'); // Fallback to default
                console.warn("Failed to create Canvas 2D context with HDR options. Falling back to default sRGB 8-bit.", ctxSrgb.getContextAttributes());
            }
        } catch (e) {
            console.error("Error creating Canvas 2D context with HDR options:", e);           
            // Display a warning if PQ context creation failed, suggesting to check browser flags.
            if (!ctxPq) {
                experimentalFlagsWarningDiv.style.display = 'block';
            } else {
                experimentalFlagsWarningDiv.style.display = 'none';
            }
            ctxPq = ctxSrgb;
        }

        let foregroundImage = new Image();
        let alphaMaskImage = new Image();

        // --- Transfer Function Conversions (CICP-based + HDR/Generic Gamma) ---

        // sRGB / IEC 61966-2-1 (CICP 6)
        function sRGBToLinear(c) {
            c /= 255;
            return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        }

        function linearTosRGB(c) {
            c = Math.max(0, Math.min(1, c)); // Clamp to 0-1
            return Math.round(255 * (c <= 0.0031308 ? c * 12.92 : (1.055 * Math.pow(c, 1 / 2.4) - 0.055)));
        }

        // BT.709 (CICP 1)
        function BT709ToLinear(c) {
            c /= 255;
            return c < 0.081 ? c / 4.5 : Math.pow((c + 0.099) / 1.099, 1 / 0.45);
        }

        function linearToBT709(c) {
            c = Math.max(0, Math.min(1, c)); // Clamp to 0-1
            return Math.round(255 * (c < 0.018 ? c * 4.5 : (1.099 * Math.pow(c, 0.45) - 0.099)));
        }

        // PQ (Perceptual Quantizer - SMPTE ST 2084)
        const SDR_WHITE_NITS = 203;
        const PQ_MAX_NITS = 10000;

        function PQToLinear(c) {
            c /= 255; // Normalize 0-255 to 0-1 for curve input
            if (c > 0.0) {
                const p = Math.pow(c, 1.0 / 78.84375);
                const num = Math.max(p - 0.8359375, 0.0);
                const den = Math.max(18.8515625 - 18.6875 * p, 0.0);
                const linear = Math.pow(num / den, 1.0 / 0.1593017578125);
                // Scale so that SDR white is 1.0 (extended SDR).
                return linear * PQ_MAX_NITS / SDR_WHITE_NITS;
            } else {
                return 0;
            }
        }

        function linearToPQ(l) {
            if (l > 0.0) {
                // Scale from extended SDR range to [0.0, 1.0].
                l = Math.max(Math.min(l * SDR_WHITE_NITS / PQ_MAX_NITS, 1.0), 0.0);
                const powLinear = Math.pow(l, 0.1593017578125);
                const num = 0.1640625 * powLinear - 0.1640625;
                const den = 1.0 + 18.6875 * powLinear;
                return Math.round(Math.pow(1.0 + num / den, 78.84375) * 255);
            } else {
                return 0;
            }
        }

        // Generic Gamma Function
        function gammaToLinear(c, gamma) {
            c /= 255;
            return Math.pow(c, gamma);
        }

        function linearToGamma(l, gamma) {
            l = Math.max(0, Math.min(1, l));
            return Math.round(255 * Math.pow(l, 1 / gamma));
        }

        // --- YUV Conversions (BT.709 coefficients used as standard for digital video) ---

        // RGB to YUV (Full Range: Y:0-255, U/V:0-255) - often scaled from 16-235/16-240
        // Based on BT.709 coefficients for Y. For U/V, standard formulas.
        function rgbToYuvFullRange(R, G, B) {
            const Y = 0.2126 * R + 0.7152 * G + 0.0722 * B;
            const U = -0.09991 * R - 0.33609 * G + 0.436 * B + 128; // U and V offsets to keep them positive
            const V = 0.615 * R - 0.55861 * G - 0.05639 * B + 128;
            return [Y, U, V];
        }

        // YUV to RGB (Full Range)
        function yuvToRgbFullRange(Y, U, V) {
            U -= 128;
            V -= 128;
            const R = Y + 1.28033 * V;
            const G = Y - 0.21482 * U - 0.38059 * V;
            const B = Y + 2.12798 * U;
            return [R, G, B];
        }

        // RGB to YUV (Limited Range / Studio Swing: Y:16-235, U/V:16-240) - BT.709
        function rgbToYuvLimitedRange(R, G, B) {
            const Y = 16 + 0.182585 * R + 0.614231 * G + 0.062002 * B;
            const U = 128 - 0.100644 * R - 0.338573 * G + 0.439217 * B;
            const V = 128 + 0.439217 * R - 0.398942 * G - 0.040275 * B;
            return [Y, U, V];
        }

        // YUV to RGB (Limited Range)
        function yuvToRgbLimitedRange(Y, U, V) {
            Y -= 16;
            U -= 128;
            V -= 128;
            const R = 1.164391 * Y + 1.792739 * V;
            const G = 1.164391 * Y - 0.2132371 * U - 0.532906 * V;
            const B = 1.164391 * Y + 2.112408 * U;
            return [R, G, B];
        }

        // --- Main Blending Logic ---

        // Function to parse hex color to RGB array [R, G, B]
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        }

        // Function to draw everything on the canvas
        const drawCanvas = () => {
            const isPq = foregroundImage.src.indexOf("-pq.") !== -1;
            const ctx = isPq ? ctxPq : ctxSrgb;
            const blendCanvas = isPq ? blendCanvasPq : blendCanvasSrgb;
            const otherCanvas = isPq ? blendCanvasSrgb : blendCanvasPq;
            blendCanvas.style.display = 'block';
            otherCanvas.style.display = 'none';
            if (!ctx) {
                console.error("Canvas 2D context is not initialized.");
                return;
            }

            const bgColor = backgroundColorSelect.value;
            const selectedBlendingOption = blendingColorSpaceSelect.value;
            const selectedTransferFunctionOption = transferFunctionSelect.value;
            const premultiplication = premultiplicationSelect.value;

            // Clear the canvas
            ctx.clearRect(0, 0, blendCanvas.width, blendCanvas.height);
            // ctx.imageSmoothingEnabled = false; // Useful for pixel art or debugging

            // Draw background color (initial display, then overwritten by blend)
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);

            // Check if both foreground image and alpha mask are loaded
            if (foregroundImage.complete && foregroundImage.naturalWidth > 0 &&
                alphaMaskImage.complete && alphaMaskImage.naturalWidth > 0) {

                blendCanvas.width = foregroundImage.naturalWidth;
                blendCanvas.height = foregroundImage.naturalHeight;

                // Create a temporary canvas for the foreground image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = blendCanvas.width;
                tempCanvas.height = blendCanvas.height;
                const tempctx = tempCanvas.getContext('2d', { colorSpace: ctx.getContextAttributes().colorSpace}); // Use a standard 2D context for temp ops

                // Draw the foreground image onto the temporary canvas
                tempctx.drawImage(foregroundImage, 0, 0, tempCanvas.width, tempCanvas.height);

                const tempCanvas2 = document.createElement('canvas');
                tempCanvas2.width = blendCanvas.width;
                tempCanvas2.height = blendCanvas.height;
                const tempctx2 = tempCanvas2.getContext('2d', { colorSpace: ctx.getContextAttributes().colorSpace}); // Use a standard 2D context for temp ops
                tempctx2.fillStyle = bgColor;
                tempctx2.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
                const backgroundData = tempctx2.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                [bgR_display, bgG_display, bgB_display] = backgroundData.data;

                const foregroundData = tempctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const foregroundPixels = foregroundData.data;

                // Create a temporary canvas for the alpha mask
                const maskTempCanvas = document.createElement('canvas');
                maskTempCanvas.width = blendCanvas.width;
                maskTempCanvas.height = blendCanvas.height;
                const maskTempctx = maskTempCanvas.getContext('2d'); // Use a standard 2D context for temp ops

                // Draw the alpha mask onto its temporary canvas
                maskTempctx.drawImage(alphaMaskImage, 0, 0, maskTempCanvas.width, maskTempCanvas.height);
                const maskData = maskTempctx.getImageData(0, 0, maskTempCanvas.width, maskTempCanvas.height);
                const maskPixels = maskData.data;

                // Prepare blended image data
                const blendedImageData = ctx.createImageData(blendCanvas.width, blendCanvas.height);
                const blendedPixels = blendedImageData.data;

                for (let i = 0; i < foregroundPixels.length; i += 4) {
                    let fgR_display = foregroundPixels[i];
                    let fgG_display = foregroundPixels[i + 1];
                    let fgB_display = foregroundPixels[i + 2];
                    const fgA_mask = maskPixels[i]; // Using Red channel of mask as alpha (0-255)

                    // Alpha is always treated as linear (0-1)
                    const alpha = fgA_mask / 255;

                    let finalR_result, finalG_result, finalB_result; // Final values for output to blendedPixels

                    // Helper function to linearize an 8-bit sRGB input value to the target linear space
                    const linearizeInput = (val, tf) => {
                        switch (tf) {
                            case 'sRGB_IEC_61966_2_1': return sRGBToLinear(val);
                            case 'BT_709': return BT709ToLinear(val);
                            case 'PQ': return PQToLinear(val); // Assumes 0-255 input scales to 0-1 for PQ curve
                            case 'HLG': return HLGToLinear(val); // Assumes 0-255 input scales to 0-1 for HLG curve
                            case 'Gamma_2_2': return gammaToLinear(val, 2.2);
                            case 'Gamma_2_4': return gammaToLinear(val, 2.4);
                            case 'Gamma_2_8': return gammaToLinear(val, 2.8);
                            default: return val / 255;
                        }
                    };

                    // Helper function to delinearize a linear 0-1 value back to 8-bit for display
                    const delinearizeOutput = (val_linear, tf) => {
                        switch (tf) {
                            case 'sRGB_IEC_61966_2_1': return linearTosRGB(val_linear);
                            case 'BT_709': return linearToBT709(val_linear);
                            case 'PQ': return linearToPQ(val_linear); // Converts 0-1 linear back to 0-255 for display
                            case 'HLG': return linearToHLG(val_linear); // Converts 0-1 linear back to 0-255 for display
                            case 'Gamma_2_2': return linearToGamma(val_linear, 2.2);
                            case 'Gamma_2_4': return linearToGamma(val_linear, 2.4);
                            case 'Gamma_2_8': return linearToGamma(val_linear, 2.8);
                            default: return Math.round(val_linear * 255);
                        }
                    };

                    if (premultiplication === 'Gamma') {
                        fgR_display *= alpha;
                        fgG_display *= alpha;
                        fgB_display *= alpha;
                    } else if (premultiplication === 'Linear') {
                        fgR_display = delinearizeOutput(linearizeInput(fgR_display, selectedTransferFunctionOption) * alpha, selectedTransferFunctionOption);
                        fgG_display = delinearizeOutput(linearizeInput(fgG_display, selectedTransferFunctionOption) * alpha, selectedTransferFunctionOption);
                        fgB_display = delinearizeOutput(linearizeInput(fgB_display, selectedTransferFunctionOption) * alpha, selectedTransferFunctionOption);
                    } else if (premultiplication === 'YUV') {
                        let premultYuvIsFullRange;
                        if (selectedBlendingOption === 'YUV_Full') {
                            premultYuvIsFullRange = true;
                        } else if (selectedBlendingOption === 'YUV_Limited') {
                            premultYuvIsFullRange = false;
                        } else { // RGB_Gamma or RGB_Linear - default to Limited for YUV premult step to match original implicit behavior
                            premultYuvIsFullRange = false;
                        }

                        let tempFgY, tempFgU, tempFgV;
                        if (premultYuvIsFullRange) {
                            [tempFgY, tempFgU, tempFgV] = rgbToYuvFullRange(fgR_display, fgG_display, fgB_display);
                        } else {
                            [tempFgY, tempFgU, tempFgV] = rgbToYuvLimitedRange(fgR_display, fgG_display, fgB_display);
                        }
                        tempFgY *= alpha;
                        tempFgU *= alpha;
                        tempFgV *= alpha;
                        if (premultYuvIsFullRange) {
                            [fgR_display, fgG_display, fgB_display] = yuvToRgbFullRange(tempFgY, tempFgU, tempFgV);
                        } else {
                            [fgR_display, fgG_display, fgB_display] = yuvToRgbLimitedRange(tempFgY, tempFgU, tempFgV);
                        }
                    }

                    if (selectedBlendingOption === 'YUV_Full' || selectedBlendingOption === 'YUV_Limited') {
                        // Convert RGB inputs to YUV first
                        let fgY, fgU, fgV;
                        let bgY, bgU, bgV;

                        if (selectedBlendingOption === 'YUV_Full') {
                            [fgY, fgU, fgV] = rgbToYuvFullRange(fgR_display, fgG_display, fgB_display);
                            [bgY, bgU, bgV] = rgbToYuvFullRange(bgR_display, bgG_display, bgB_display);
                        } else { // YUV_Limited
                            [fgY, fgU, fgV] = rgbToYuvLimitedRange(fgR_display, fgG_display, fgB_display);
                            [bgY, bgU, bgV] = rgbToYuvLimitedRange(bgR_display, bgG_display, bgB_display);
                        }


                        if (premultiplication === 'None') {
                            fgY *= alpha;
                            fgU *= alpha;
                            fgV *= alpha;
                        }
                        // Perform blending in YUV space
                        const blendedY = fgY + bgY * (1 - alpha);
                        const blendedU = fgU + bgU * (1 - alpha);
                        const blendedV = fgV + bgV * (1 - alpha);

                        // Convert blended YUV back to RGB for display
                        if (selectedBlendingOption === 'YUV_Full') {
                            [finalR_result, finalG_result, finalB_result] = yuvToRgbFullRange(blendedY, blendedU, blendedV);
                        } else { // YUV_Limited
                            [finalR_result, finalG_result, finalB_result] = yuvToRgbLimitedRange(blendedY, blendedU, blendedV);
                        }

                        // Clamp values to 0-255
                        blendedPixels[i] = Math.round(Math.max(0, Math.min(255, finalR_result)));
                        blendedPixels[i + 1] = Math.round(Math.max(0, Math.min(255, finalG_result)));
                        blendedPixels[i + 2] = Math.round(Math.max(0, Math.min(255, finalB_result)));

                    } else { // RGB Blending (Gamma or Linear)
                        if (selectedBlendingOption === 'RGB_Gamma') {
                            if (premultiplication === 'None') {
                                fgR_display *= alpha;
                                fgG_display *= alpha;
                                fgB_display *= alpha;
                            }
                            // Perform blending directly in gamma-compressed space
                            blendedPixels[i] = Math.round(fgR_display + bgR_display * (1 - alpha));
                            blendedPixels[i + 1] = Math.round(fgG_display + bgG_display * (1 - alpha));
                            blendedPixels[i + 2] = Math.round(fgB_display + bgB_display * (1 - alpha));
                        } else if (selectedBlendingOption === 'RGB_Linear') {
                            let linearFgR = linearizeInput(fgR_display, selectedTransferFunctionOption);
                            let linearFgG = linearizeInput(fgG_display, selectedTransferFunctionOption);
                            let linearFgB = linearizeInput(fgB_display, selectedTransferFunctionOption);

                            const linearBgR = linearizeInput(bgR_display, selectedTransferFunctionOption);
                            const linearBgG = linearizeInput(bgG_display, selectedTransferFunctionOption);
                            const linearBgB = linearizeInput(bgB_display, selectedTransferFunctionOption);

                            if (premultiplication === 'None') {
                                linearFgR *= alpha;
                                linearFgG *= alpha;
                                linearFgB *= alpha;
                            }

                            // Perform blending in linear space
                            const blendedR_linear = linearFgR + linearBgR * (1 - alpha);
                            const blendedG_linear = linearFgG + linearBgG * (1 - alpha);
                            const blendedB_linear = linearFgB + linearBgB * (1 - alpha);

                            // Delinearize the result back to the selected transfer function's gamma space for display
                            blendedPixels[i] = delinearizeOutput(blendedR_linear, selectedTransferFunctionOption);
                            blendedPixels[i + 1] = delinearizeOutput(blendedG_linear, selectedTransferFunctionOption);
                            blendedPixels[i + 2] = delinearizeOutput(blendedB_linear, selectedTransferFunctionOption);
                        }
                    }

                    // Always set full opacity for the final blended image for display
                    blendedPixels[i + 3] = 255;
                }

                // Put the final blended image data onto the main canvas
                ctx.putImageData(blendedImageData, 0, 0);
            } else {
                // Display a message or handle cases where images are not loaded
                ctx.font = '20px Arial';
                ctx.fillStyle = '#666';
                ctx.fillText('Loading images...', blendCanvas.width / 2 - 80, blendCanvas.height / 2);
            }
        };

        // Event listeners for changes in dropdowns
        backgroundColorSelect.addEventListener('change', () => {
            updateBackgroundColorPreview(backgroundColorSelect.value);
            drawCanvas();
            saveSettingsToHash();
        });
        foregroundImageSelect.addEventListener('change', () => {
            // When image selection changes, load the new image and then redraw
            updateForegroundImage(foregroundImageSelect.value);
            adjustTransferFunctionForImage(foregroundImage.src); // Adjust TF before saving hash
            // drawCanvas will be called by foregroundImage.onload
            saveSettingsToHash(); // Save new image and potentially new TF
        });
        alphaMaskSelect.addEventListener('change', () => {
            // When mask selection changes, load the new mask and then redraw
            updateAlphaMask(alphaMaskSelect.value);
            // drawCanvas will be called by alphaMaskImage.onload
            saveSettingsToHash();
        });
        blendingColorSpaceSelect.addEventListener('change', () => { drawCanvas(); saveSettingsToHash(); });
        transferFunctionSelect.addEventListener('change', () => { drawCanvas(); saveSettingsToHash(); });
        premultiplicationSelect.addEventListener('change', () => { drawCanvas(); saveSettingsToHash(); });
        // exposureSlider.addEventListener('input', drawCanvas); // Not used in 2D canvas version for now

        // Set up image loading handlers
        foregroundImage.onload = () => {
            const naturalWidth = foregroundImage.naturalWidth;
            const naturalHeight = foregroundImage.naturalHeight;

            if (naturalWidth > 0 && naturalHeight > 0) {
                const aspectRatio = naturalWidth / naturalHeight;
                const previewWidth = 150; // Must match CSS width for .preview-item img
                const previewHeight = previewWidth / aspectRatio;

                // Apply this height to all three preview elements
                backgroundPreview.style.height = `${previewHeight}px`;
                foregroundPreview.style.height = `${previewHeight}px`;
                alphaMaskPreview.style.height = `${previewHeight}px`;
            }
            drawCanvas();
        };
        foregroundImage.onerror = () => console.error("Error loading foreground image");

        alphaMaskImage.onload = () => {
            drawCanvas();
        };
        alphaMaskImage.onerror = () => console.error("Error loading alpha mask image");

        // Initial setup: Load settings from hash first
        loadSettingsFromHash();

        // Set initial image sources based on select values (which might have been loaded from hash)
        updateForegroundImage(foregroundImageSelect.value);
        updateAlphaMask(alphaMaskSelect.value);
        updateBackgroundColorPreview(backgroundColorSelect.value);

        // Adjust transfer function based on the initially selected/loaded foreground image
        const tfChangedOnLoad = adjustTransferFunctionForImage(foregroundImage.src);
        if (tfChangedOnLoad) {
            saveSettingsToHash(); // If TF was auto-adjusted, update the hash
        }

        // Initial draw
        // drawCanvas will be called by the image onload handlers.
        // Calling it here explicitly is okay as it handles the "Loading images..." state.
        drawCanvas();
    });
    </script>
</body>
</html>